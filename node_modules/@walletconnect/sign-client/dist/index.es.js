import B from"pino";import{RELAYER_DEFAULT_PROTOCOL as Q,RELAYER_EVENTS as W,EXPIRER_EVENTS as ee,Store as U,Core as se}from"@walletconnect/core";import{getDefaultLoggerOptions as te,generateChildLogger as ie,getLoggerContext as re}from"@walletconnect/logger";import{IEngine as ne,ISignClient as oe}from"@walletconnect/types";import{TYPE_1 as ae,createDelayedPromise as R,engineEvent as p,getInternalError as a,calcExpiry as N,getSdkError as E,isSessionCompatible as ce,isExpired as f,isValidParams as m,isUndefined as le,isValidRequiredNamespaces as pe,isValidRelays as he,isValidNamespaces as b,isConformingNamespaces as z,isValidString as x,isValidErrorReason as de,isValidRelay as ge,isValidController as we,isValidNamespacesChainId as j,isValidRequest as me,isValidNamespacesRequest as ue,isValidResponse as ye,isValidEvent as Se,isValidNamespacesEvent as Ee,parseExpirerTarget as Ie,isValidId as _e,getAppMetadata as Re}from"@walletconnect/utils";import Ne,{EventEmitter as fe}from"events";import{THIRTY_DAYS as ve,SEVEN_DAYS as Ve,FIVE_MINUTES as u,ONE_DAY as v,THIRTY_SECONDS as k}from"@walletconnect/time";import{isJsonRpcResult as I,isJsonRpcError as _,formatJsonRpcRequest as Oe,formatJsonRpcResult as qe,formatJsonRpcError as Pe,isJsonRpcRequest as Te,isJsonRpcResponse as xe}from"@walletconnect/jsonrpc-utils";const G="wc",$=2,M="client",K=`${G}@${$}:${M}:`,D={name:M,logger:"error",controller:!1,relayUrl:"wss://relay.walletconnect.com"},De={session_proposal:"session_proposal",session_update:"session_update",session_extend:"session_extend",session_ping:"session_ping",session_delete:"session_delete",session_expire:"session_expire",session_request:"session_request",session_event:"session_event",proposal_expire:"proposal_expire"},Ae={database:":memory:"},Ce={created:"history_created",updated:"history_updated",deleted:"history_deleted",sync:"history_sync"},Le="history",be="0.3",Y="proposal",Ge=ve,J="session",q=Ve,X="engine",P={wc_sessionPropose:{req:{ttl:u,prompt:!0,tag:1100},res:{ttl:u,prompt:!1,tag:1101}},wc_sessionSettle:{req:{ttl:u,prompt:!1,tag:1102},res:{ttl:u,prompt:!1,tag:1103}},wc_sessionUpdate:{req:{ttl:v,prompt:!1,tag:1104},res:{ttl:v,prompt:!1,tag:1105}},wc_sessionExtend:{req:{ttl:v,prompt:!1,tag:1106},res:{ttl:v,prompt:!1,tag:1107}},wc_sessionRequest:{req:{ttl:u,prompt:!0,tag:1108},res:{ttl:u,prompt:!1,tag:1109}},wc_sessionEvent:{req:{ttl:u,prompt:!0,tag:1110},res:{ttl:u,prompt:!1,tag:1111}},wc_sessionDelete:{req:{ttl:v,prompt:!1,tag:1112},res:{ttl:v,prompt:!1,tag:1113}},wc_sessionPing:{req:{ttl:k,prompt:!1,tag:1114},res:{ttl:k,prompt:!1,tag:1115}}};var $e=Object.defineProperty,Me=Object.defineProperties,Ke=Object.getOwnPropertyDescriptors,H=Object.getOwnPropertySymbols,Ue=Object.prototype.hasOwnProperty,ze=Object.prototype.propertyIsEnumerable,F=(h,r,e)=>r in h?$e(h,r,{enumerable:!0,configurable:!0,writable:!0,value:e}):h[r]=e,S=(h,r)=>{for(var e in r||(r={}))Ue.call(r,e)&&F(h,e,r[e]);if(H)for(var e of H(r))ze.call(r,e)&&F(h,e,r[e]);return h},Z=(h,r)=>Me(h,Ke(r));class je extends ne{constructor(r){super(r),this.name=X,this.events=new Ne,this.initialized=!1,this.ignoredPayloadTypes=[ae],this.init=async()=>{this.initialized||(await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.client.core.pairing.register({methods:Object.keys(P)}),this.initialized=!0)},this.connect=async e=>{this.isInitialized(),await this.isValidConnect(e);const{pairingTopic:s,requiredNamespaces:t,relays:i}=e;let n=s,o,c=!1;if(n&&(c=this.client.core.pairing.pairings.get(n).active),!n||!c){const{topic:y,uri:d}=await this.client.core.pairing.create();n=y,o=d}const l=await this.client.core.crypto.generateKeyPair(),g={requiredNamespaces:t,relays:i??[{protocol:Q}],proposer:{publicKey:l,metadata:this.client.metadata}},{reject:w,resolve:V,done:C}=R();if(this.events.once(p("session_connect"),async({error:y,session:d})=>{if(y)w(y);else if(d){d.self.publicKey=l;const O=Z(S({},d),{requiredNamespaces:t});await this.client.session.set(d.topic,O),await this.setExpiry(d.topic,d.expiry),n&&await this.client.core.pairing.updateMetadata({topic:n,metadata:d.peer.metadata}),V(O)}}),!n){const{message:y}=a("NO_MATCHING_KEY",`connect() pairing topic: ${n}`);throw new Error(y)}const T=await this.sendRequest(n,"wc_sessionPropose",g),L=N(u);return await this.setProposal(T,S({id:T,expiry:L},g)),{uri:o,approval:C}},this.pair=async e=>(this.isInitialized(),await this.client.core.pairing.pair(e)),this.approve=async e=>{this.isInitialized(),await this.isValidApprove(e);const{id:s,relayProtocol:t,namespaces:i}=e,{pairingTopic:n,proposer:o,requiredNamespaces:c}=this.client.proposal.get(s),l=await this.client.core.crypto.generateKeyPair(),g=o.publicKey,w=await this.client.core.crypto.generateSharedKey(l,g),V={relay:{protocol:t??"irn"},namespaces:i,requiredNamespaces:c,controller:{publicKey:l,metadata:this.client.metadata},expiry:N(q)};await this.client.core.relayer.subscribe(w);const C=await this.sendRequest(w,"wc_sessionSettle",V),{done:T,resolve:L,reject:y}=R();this.events.once(p("session_approve",C),({error:O})=>{O?y(O):L(this.client.session.get(w))});const d=Z(S({},V),{topic:w,acknowledged:!1,self:V.controller,peer:{publicKey:o.publicKey,metadata:o.metadata},controller:l});return await this.client.session.set(w,d),await this.setExpiry(w,N(q)),n&&await this.client.core.pairing.updateMetadata({topic:n,metadata:d.peer.metadata}),n&&s&&(await this.sendResult(s,n,{relay:{protocol:t??"irn"},responderPublicKey:l}),await this.client.proposal.delete(s,E("USER_DISCONNECTED")),await this.client.core.pairing.activate({topic:n})),{topic:w,acknowledged:T}},this.reject=async e=>{this.isInitialized(),await this.isValidReject(e);const{id:s,reason:t}=e,{pairingTopic:i}=this.client.proposal.get(s);i&&(await this.sendError(s,i,t),await this.client.proposal.delete(s,E("USER_DISCONNECTED")))},this.update=async e=>{this.isInitialized(),await this.isValidUpdate(e);const{topic:s,namespaces:t}=e,i=await this.sendRequest(s,"wc_sessionUpdate",{namespaces:t}),{done:n,resolve:o,reject:c}=R();return this.events.once(p("session_update",i),({error:l})=>{l?c(l):o()}),await this.client.session.update(s,{namespaces:t}),{acknowledged:n}},this.extend=async e=>{this.isInitialized(),await this.isValidExtend(e);const{topic:s}=e,t=await this.sendRequest(s,"wc_sessionExtend",{}),{done:i,resolve:n,reject:o}=R();return this.events.once(p("session_extend",t),({error:c})=>{c?o(c):n()}),await this.setExpiry(s,N(q)),{acknowledged:i}},this.request=async e=>{this.isInitialized(),await this.isValidRequest(e);const{chainId:s,request:t,topic:i}=e,n=await this.sendRequest(i,"wc_sessionRequest",{request:t,chainId:s}),{done:o,resolve:c,reject:l}=R();return this.events.once(p("session_request",n),({error:g,result:w})=>{g?l(g):c(w)}),await o()},this.respond=async e=>{this.isInitialized(),await this.isValidRespond(e);const{topic:s,response:t}=e,{id:i}=t;I(t)?await this.sendResult(i,s,t.result):_(t)&&await this.sendError(i,s,t.error)},this.ping=async e=>{this.isInitialized(),await this.isValidPing(e);const{topic:s}=e;if(this.client.session.keys.includes(s)){const t=await this.sendRequest(s,"wc_sessionPing",{}),{done:i,resolve:n,reject:o}=R();this.events.once(p("session_ping",t),({error:c})=>{c?o(c):n()}),await i()}else this.client.core.pairing.pairings.keys.includes(s)&&await this.client.core.pairing.ping({topic:s})},this.emit=async e=>{this.isInitialized(),await this.isValidEmit(e);const{topic:s,event:t,chainId:i}=e;await this.sendRequest(s,"wc_sessionEvent",{event:t,chainId:i})},this.disconnect=async e=>{this.isInitialized(),await this.isValidDisconnect(e);const{topic:s}=e;this.client.session.keys.includes(s)?(await this.sendRequest(s,"wc_sessionDelete",E("USER_DISCONNECTED")),await this.deleteSession(s)):await this.client.core.pairing.disconnect({topic:s})},this.find=e=>(this.isInitialized(),this.client.session.getAll().filter(s=>ce(s,e))),this.deleteSession=async(e,s)=>{const{self:t}=this.client.session.get(e);await this.client.core.relayer.unsubscribe(e),await Promise.all([this.client.session.delete(e,E("USER_DISCONNECTED")),this.client.core.crypto.deleteKeyPair(t.publicKey),this.client.core.crypto.deleteSymKey(e),s?Promise.resolve():this.client.core.expirer.del(e)])},this.deleteProposal=async(e,s)=>{await Promise.all([this.client.proposal.delete(e,E("USER_DISCONNECTED")),s?Promise.resolve():this.client.core.expirer.del(e)])},this.setExpiry=async(e,s)=>{this.client.session.keys.includes(e)&&await this.client.session.update(e,{expiry:s}),this.client.core.expirer.set(e,s)},this.setProposal=async(e,s)=>{await this.client.proposal.set(e,s),this.client.core.expirer.set(e,s.expiry)},this.sendRequest=async(e,s,t)=>{const i=Oe(s,t),n=await this.client.core.crypto.encode(e,i),o=P[s].req;return this.client.core.history.set(e,i),this.client.core.relayer.publish(e,n,o),i.id},this.sendResult=async(e,s,t)=>{const i=qe(e,t),n=await this.client.core.crypto.encode(s,i),o=await this.client.core.history.get(s,e),c=P[o.request.method].res;this.client.core.relayer.publish(s,n,c),await this.client.core.history.resolve(i)},this.sendError=async(e,s,t)=>{const i=Pe(e,t),n=await this.client.core.crypto.encode(s,i),o=await this.client.core.history.get(s,e),c=P[o.request.method].res;this.client.core.relayer.publish(s,n,c),await this.client.core.history.resolve(i)},this.cleanup=async()=>{const e=[],s=[];this.client.session.getAll().forEach(t=>{f(t.expiry)&&e.push(t.topic)}),this.client.proposal.getAll().forEach(t=>{f(t.expiry)&&s.push(t.id)}),await Promise.all([...e.map(t=>this.deleteSession(t)),...s.map(t=>this.deleteProposal(t))])},this.onRelayEventRequest=e=>{const{topic:s,payload:t}=e,i=t.method;switch(i){case"wc_sessionPropose":return this.onSessionProposeRequest(s,t);case"wc_sessionSettle":return this.onSessionSettleRequest(s,t);case"wc_sessionUpdate":return this.onSessionUpdateRequest(s,t);case"wc_sessionExtend":return this.onSessionExtendRequest(s,t);case"wc_sessionPing":return this.onSessionPingRequest(s,t);case"wc_sessionDelete":return this.onSessionDeleteRequest(s,t);case"wc_sessionRequest":return this.onSessionRequest(s,t);case"wc_sessionEvent":return this.onSessionEventRequest(s,t);default:return this.client.logger.info(`Unsupported request method ${i}`)}},this.onRelayEventResponse=async e=>{const{topic:s,payload:t}=e,i=(await this.client.core.history.get(s,t.id)).request.method;switch(i){case"wc_sessionPropose":return this.onSessionProposeResponse(s,t);case"wc_sessionSettle":return this.onSessionSettleResponse(s,t);case"wc_sessionUpdate":return this.onSessionUpdateResponse(s,t);case"wc_sessionExtend":return this.onSessionExtendResponse(s,t);case"wc_sessionPing":return this.onSessionPingResponse(s,t);case"wc_sessionRequest":return this.onSessionRequestResponse(s,t);default:return this.client.logger.info(`Unsupported response method ${i}`)}},this.onSessionProposeRequest=async(e,s)=>{const{params:t,id:i}=s;try{this.isValidConnect(S({},s.params));const n=N(u),o=S({id:i,pairingTopic:e,expiry:n},t);await this.setProposal(i,o),this.client.events.emit("session_proposal",{id:i,params:o})}catch(n){await this.sendError(i,e,n),this.client.logger.error(n)}},this.onSessionProposeResponse=async(e,s)=>{const{id:t}=s;if(I(s)){const{result:i}=s;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",result:i});const n=this.client.proposal.get(t);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",proposal:n});const o=n.proposer.publicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",selfPublicKey:o});const c=i.responderPublicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",peerPublicKey:c});const l=await this.client.core.crypto.generateSharedKey(o,c);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",sessionTopic:l});const g=await this.client.core.relayer.subscribe(l);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",subscriptionId:g}),await this.client.core.pairing.activate({topic:e})}else _(s)&&(await this.client.proposal.delete(t,E("USER_DISCONNECTED")),this.events.emit(p("session_connect"),{error:s.error}))},this.onSessionSettleRequest=async(e,s)=>{const{id:t,params:i}=s;try{this.isValidSessionSettleRequest(i);const{relay:n,controller:o,expiry:c,namespaces:l}=s.params,g={topic:e,relay:n,expiry:c,namespaces:l,acknowledged:!0,controller:o.publicKey,self:{publicKey:"",metadata:this.client.metadata},peer:{publicKey:o.publicKey,metadata:o.metadata}};await this.sendResult(s.id,e,!0),this.events.emit(p("session_connect"),{session:g})}catch(n){await this.sendError(t,e,n),this.client.logger.error(n)}},this.onSessionSettleResponse=async(e,s)=>{const{id:t}=s;I(s)?(await this.client.session.update(e,{acknowledged:!0}),this.events.emit(p("session_approve",t),{})):_(s)&&(await this.client.session.delete(e,E("USER_DISCONNECTED")),this.events.emit(p("session_approve",t),{error:s.error}))},this.onSessionUpdateRequest=async(e,s)=>{const{params:t,id:i}=s;try{this.isValidUpdate(S({topic:e},t)),await this.client.session.update(e,{namespaces:t.namespaces}),await this.sendResult(i,e,!0),this.client.events.emit("session_update",{id:i,topic:e,params:t})}catch(n){await this.sendError(i,e,n),this.client.logger.error(n)}},this.onSessionUpdateResponse=(e,s)=>{const{id:t}=s;I(s)?this.events.emit(p("session_update",t),{}):_(s)&&this.events.emit(p("session_update",t),{error:s.error})},this.onSessionExtendRequest=async(e,s)=>{const{id:t}=s;try{this.isValidExtend({topic:e}),await this.setExpiry(e,N(q)),await this.sendResult(t,e,!0),this.client.events.emit("session_extend",{id:t,topic:e})}catch(i){await this.sendError(t,e,i),this.client.logger.error(i)}},this.onSessionExtendResponse=(e,s)=>{const{id:t}=s;I(s)?this.events.emit(p("session_extend",t),{}):_(s)&&this.events.emit(p("session_extend",t),{error:s.error})},this.onSessionPingRequest=async(e,s)=>{const{id:t}=s;try{this.isValidPing({topic:e}),await this.sendResult(t,e,!0),this.client.events.emit("session_ping",{id:t,topic:e})}catch(i){await this.sendError(t,e,i),this.client.logger.error(i)}},this.onSessionPingResponse=(e,s)=>{const{id:t}=s;setTimeout(()=>{I(s)?this.events.emit(p("session_ping",t),{}):_(s)&&this.events.emit(p("session_ping",t),{error:s.error})},500)},this.onSessionDeleteRequest=async(e,s)=>{const{id:t}=s;try{this.isValidDisconnect({topic:e,reason:s.params}),await this.sendResult(t,e,!0),await this.deleteSession(e),this.client.events.emit("session_delete",{id:t,topic:e})}catch(i){await this.sendError(t,e,i),this.client.logger.error(i)}},this.onSessionRequest=async(e,s)=>{const{id:t,params:i}=s;try{this.isValidRequest(S({topic:e},i)),this.client.events.emit("session_request",{id:t,topic:e,params:i})}catch(n){await this.sendError(t,e,n),this.client.logger.error(n)}},this.onSessionRequestResponse=(e,s)=>{const{id:t}=s;I(s)?this.events.emit(p("session_request",t),{result:s.result}):_(s)&&this.events.emit(p("session_request",t),{error:s.error})},this.onSessionEventRequest=async(e,s)=>{const{id:t,params:i}=s;try{this.isValidEmit(S({topic:e},i)),this.client.events.emit("session_event",{id:t,topic:e,params:i})}catch(n){await this.sendError(t,e,n),this.client.logger.error(n)}},this.isValidConnect=async e=>{if(!m(e)){const{message:o}=a("MISSING_OR_INVALID",`connect() params: ${JSON.stringify(e)}`);throw new Error(o)}const{pairingTopic:s,requiredNamespaces:t,relays:i}=e;le(s)||await this.isValidPairingTopic(s);const n=pe(t,"connect()");if(n)throw new Error(n.message);if(!he(i,!0)){const{message:o}=a("MISSING_OR_INVALID",`connect() relays: ${i}`);throw new Error(o)}},this.isValidApprove=async e=>{if(!m(e))throw new Error(a("MISSING_OR_INVALID",`approve() params: ${e}`).message);const{id:s,namespaces:t,relayProtocol:i}=e;await this.isValidProposalId(s);const n=this.client.proposal.get(s),o=b(t,"approve()");if(o)throw new Error(o.message);const c=z(n.requiredNamespaces,t,"update()");if(c)throw new Error(c.message);if(!x(i,!0)){const{message:l}=a("MISSING_OR_INVALID",`approve() relayProtocol: ${i}`);throw new Error(l)}},this.isValidReject=async e=>{if(!m(e)){const{message:i}=a("MISSING_OR_INVALID",`reject() params: ${e}`);throw new Error(i)}const{id:s,reason:t}=e;if(await this.isValidProposalId(s),!de(t)){const{message:i}=a("MISSING_OR_INVALID",`reject() reason: ${JSON.stringify(t)}`);throw new Error(i)}},this.isValidSessionSettleRequest=e=>{if(!m(e)){const{message:l}=a("MISSING_OR_INVALID",`onSessionSettleRequest() params: ${e}`);throw new Error(l)}const{relay:s,controller:t,namespaces:i,expiry:n}=e;if(!ge(s)){const{message:l}=a("MISSING_OR_INVALID","onSessionSettleRequest() relay protocol should be a string");throw new Error(l)}const o=we(t,"onSessionSettleRequest()");if(o)throw new Error(o.message);const c=b(i,"onSessionSettleRequest()");if(c)throw new Error(c.message);if(f(n)){const{message:l}=a("EXPIRED","onSessionSettleRequest()");throw new Error(l)}},this.isValidUpdate=async e=>{if(!m(e)){const{message:c}=a("MISSING_OR_INVALID",`update() params: ${e}`);throw new Error(c)}const{topic:s,namespaces:t}=e;await this.isValidSessionTopic(s);const i=this.client.session.get(s),n=b(t,"update()");if(n)throw new Error(n.message);const o=z(i.requiredNamespaces,t,"update()");if(o)throw new Error(o.message)},this.isValidExtend=async e=>{if(!m(e)){const{message:t}=a("MISSING_OR_INVALID",`extend() params: ${e}`);throw new Error(t)}const{topic:s}=e;await this.isValidSessionTopic(s)},this.isValidRequest=async e=>{if(!m(e)){const{message:o}=a("MISSING_OR_INVALID",`request() params: ${e}`);throw new Error(o)}const{topic:s,request:t,chainId:i}=e;await this.isValidSessionTopic(s);const{namespaces:n}=this.client.session.get(s);if(!j(n,i)){const{message:o}=a("MISSING_OR_INVALID",`request() chainId: ${i}`);throw new Error(o)}if(!me(t)){const{message:o}=a("MISSING_OR_INVALID",`request() ${JSON.stringify(t)}`);throw new Error(o)}if(!ue(n,i,t.method)){const{message:o}=a("MISSING_OR_INVALID",`request() method: ${t.method}`);throw new Error(o)}},this.isValidRespond=async e=>{if(!m(e)){const{message:i}=a("MISSING_OR_INVALID",`respond() params: ${e}`);throw new Error(i)}const{topic:s,response:t}=e;if(await this.isValidSessionTopic(s),!ye(t)){const{message:i}=a("MISSING_OR_INVALID",`respond() response: ${JSON.stringify(t)}`);throw new Error(i)}},this.isValidPing=async e=>{if(!m(e)){const{message:t}=a("MISSING_OR_INVALID",`ping() params: ${e}`);throw new Error(t)}const{topic:s}=e;await this.isValidSessionOrPairingTopic(s)},this.isValidEmit=async e=>{if(!m(e)){const{message:o}=a("MISSING_OR_INVALID",`emit() params: ${e}`);throw new Error(o)}const{topic:s,event:t,chainId:i}=e;await this.isValidSessionTopic(s);const{namespaces:n}=this.client.session.get(s);if(!j(n,i)){const{message:o}=a("MISSING_OR_INVALID",`emit() chainId: ${i}`);throw new Error(o)}if(!Se(t)){const{message:o}=a("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(t)}`);throw new Error(o)}if(!Ee(n,i,t.name)){const{message:o}=a("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(t)}`);throw new Error(o)}},this.isValidDisconnect=async e=>{if(!m(e)){const{message:t}=a("MISSING_OR_INVALID",`disconnect() params: ${e}`);throw new Error(t)}const{topic:s}=e;await this.isValidSessionOrPairingTopic(s)}}isInitialized(){if(!this.initialized){const{message:r}=a("NOT_INITIALIZED",this.name);throw new Error(r)}}registerRelayerEvents(){this.client.core.relayer.on(W.message,async r=>{const{topic:e,message:s}=r;if(this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(s)))return;const t=await this.client.core.crypto.decode(e,s);Te(t)?(this.client.core.history.set(e,t),this.onRelayEventRequest({topic:e,payload:t})):xe(t)&&(await this.client.core.history.resolve(t),this.onRelayEventResponse({topic:e,payload:t}))})}registerExpirerEvents(){this.client.core.expirer.on(ee.expired,async r=>{const{topic:e,id:s}=Ie(r.target);e?this.client.session.keys.includes(e)&&(await this.deleteSession(e,!0),this.client.events.emit("session_expire",{topic:e})):s&&await this.deleteProposal(s,!0)})}isValidPairingTopic(r){if(!x(r,!1)){const{message:e}=a("MISSING_OR_INVALID",`pairing topic should be a string: ${r}`);throw new Error(e)}if(!this.client.core.pairing.pairings.keys.includes(r)){const{message:e}=a("NO_MATCHING_KEY",`pairing topic doesn't exist: ${r}`);throw new Error(e)}if(f(this.client.core.pairing.pairings.get(r).expiry)){const{message:e}=a("EXPIRED",`pairing topic: ${r}`);throw new Error(e)}}async isValidSessionTopic(r){if(!x(r,!1)){const{message:e}=a("MISSING_OR_INVALID",`session topic should be a string: ${r}`);throw new Error(e)}if(!this.client.session.keys.includes(r)){const{message:e}=a("NO_MATCHING_KEY",`session topic doesn't exist: ${r}`);throw new Error(e)}if(f(this.client.session.get(r).expiry)){await this.deleteSession(r);const{message:e}=a("EXPIRED",`session topic: ${r}`);throw new Error(e)}}async isValidSessionOrPairingTopic(r){if(this.client.session.keys.includes(r))await this.isValidSessionTopic(r);else if(this.client.core.pairing.pairings.keys.includes(r))this.isValidPairingTopic(r);else if(x(r,!1)){const{message:e}=a("NO_MATCHING_KEY",`session or pairing topic doesn't exist: ${r}`);throw new Error(e)}else{const{message:e}=a("MISSING_OR_INVALID",`session or pairing topic should be a string: ${r}`);throw new Error(e)}}async isValidProposalId(r){if(!_e(r)){const{message:e}=a("MISSING_OR_INVALID",`proposal id should be a number: ${r}`);throw new Error(e)}if(!this.client.proposal.keys.includes(r)){const{message:e}=a("NO_MATCHING_KEY",`proposal id doesn't exist: ${r}`);throw new Error(e)}if(f(this.client.proposal.get(r).expiry)){await this.deleteProposal(r);const{message:e}=a("EXPIRED",`proposal id: ${r}`);throw new Error(e)}}}class ke extends U{constructor(r,e){super(r,e,Y,K),this.core=r,this.logger=e}}class Ye extends U{constructor(r,e){super(r,e,J,K),this.core=r,this.logger=e}}class A extends oe{constructor(r){super(r),this.protocol=G,this.version=$,this.name=D.name,this.events=new fe,this.on=(s,t)=>this.events.on(s,t),this.once=(s,t)=>this.events.once(s,t),this.off=(s,t)=>this.events.off(s,t),this.removeListener=(s,t)=>this.events.removeListener(s,t),this.connect=async s=>{try{return await this.engine.connect(s)}catch(t){throw this.logger.error(t.message),t}},this.pair=async s=>{try{return await this.engine.pair(s)}catch(t){throw this.logger.error(t.message),t}},this.approve=async s=>{try{return await this.engine.approve(s)}catch(t){throw this.logger.error(t.message),t}},this.reject=async s=>{try{return await this.engine.reject(s)}catch(t){throw this.logger.error(t.message),t}},this.update=async s=>{try{return await this.engine.update(s)}catch(t){throw this.logger.error(t.message),t}},this.extend=async s=>{try{return await this.engine.extend(s)}catch(t){throw this.logger.error(t.message),t}},this.request=async s=>{try{return await this.engine.request(s)}catch(t){throw this.logger.error(t.message),t}},this.respond=async s=>{try{return await this.engine.respond(s)}catch(t){throw this.logger.error(t.message),t}},this.ping=async s=>{try{return await this.engine.ping(s)}catch(t){throw this.logger.error(t.message),t}},this.emit=async s=>{try{return await this.engine.emit(s)}catch(t){throw this.logger.error(t.message),t}},this.disconnect=async s=>{try{return await this.engine.disconnect(s)}catch(t){throw this.logger.error(t.message),t}},this.find=s=>{try{return this.engine.find(s)}catch(t){throw this.logger.error(t.message),t}},this.name=r?.name||D.name,this.metadata=r?.metadata||Re();const e=typeof r?.logger<"u"&&typeof r?.logger!="string"?r.logger:B(te({level:r?.logger||D.logger}));this.core=r?.core||new se(r),this.logger=ie(e,this.name),this.session=new Ye(this.core,this.logger),this.proposal=new ke(this.core,this.logger),this.engine=new je(this)}static async init(r){const e=new A(r);return await e.initialize(),e}get context(){return re(this.logger)}get pairing(){return this.core.pairing.pairings}async initialize(){this.logger.trace("Initialized");try{await this.core.start(),await this.session.init(),await this.proposal.init(),await this.engine.init(),this.logger.info("SignClient Initilization Success")}catch(r){throw this.logger.info("SignClient Initilization Failure"),this.logger.error(r.message),r}}}const Je=A;export{X as ENGINE_CONTEXT,P as ENGINE_RPC_OPTS,Le as HISTORY_CONTEXT,Ce as HISTORY_EVENTS,be as HISTORY_STORAGE_VERSION,Y as PROPOSAL_CONTEXT,Ge as PROPOSAL_EXPIRY,J as SESSION_CONTEXT,q as SESSION_EXPIRY,M as SIGN_CLIENT_CONTEXT,D as SIGN_CLIENT_DEFAULT,De as SIGN_CLIENT_EVENTS,G as SIGN_CLIENT_PROTOCOL,Ae as SIGN_CLIENT_STORAGE_OPTIONS,K as SIGN_CLIENT_STORAGE_PREFIX,$ as SIGN_CLIENT_VERSION,Je as SignClient,A as default};
//# sourceMappingURL=index.es.js.map
